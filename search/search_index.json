{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to foxOps The intention of this project is to enable a gitOps approach to the configuration and management of GitLab repositories and instances. The project's philosophy is to leverage existing frameworks and libraries wherever possible, and to simplify configuration into a pull-diff-plan-push workflow. The tool will retain no state of its own, and will be a Python command-line tool. Contents The information is laid out into different types of documents: Guides: narrative format intended to explain how things work or how to utilise things Specifications: purely facts on the attributes or nature of things Registers: listings Figures: tables, diagrams, charts, all kinds of visual aids Templates: structures to be copied when producing artifacts The following links are manually maintained until #22 is resolved. Guides: Road map Users Registers: Decisions Requirements Templates: Y-statements","title":"Welcome to foxOps"},{"location":"#welcome-to-foxops","text":"The intention of this project is to enable a gitOps approach to the configuration and management of GitLab repositories and instances. The project's philosophy is to leverage existing frameworks and libraries wherever possible, and to simplify configuration into a pull-diff-plan-push workflow. The tool will retain no state of its own, and will be a Python command-line tool.","title":"Welcome to foxOps"},{"location":"#contents","text":"The information is laid out into different types of documents: Guides: narrative format intended to explain how things work or how to utilise things Specifications: purely facts on the attributes or nature of things Registers: listings Figures: tables, diagrams, charts, all kinds of visual aids Templates: structures to be copied when producing artifacts The following links are manually maintained until #22 is resolved. Guides: Road map Users Registers: Decisions Requirements Templates: Y-statements","title":"Contents"},{"location":"guides/road-map/","text":"Road map This page outlines the general direction and milestones for the project. Note that this is subject to change at this time. Configure a repository structure and development workflow including: Automated testing Linting Syntax checking Code formatting Documentation Containerisation? Pull repository configuration Diff repository configuration Diff based on configuration 'fingerprints' Plan repository configuration Push repository configuration Same but for GitLab admin config","title":"Road map"},{"location":"guides/road-map/#road-map","text":"This page outlines the general direction and milestones for the project. Note that this is subject to change at this time. Configure a repository structure and development workflow including: Automated testing Linting Syntax checking Code formatting Documentation Containerisation? Pull repository configuration Diff repository configuration Diff based on configuration 'fingerprints' Plan repository configuration Push repository configuration Same but for GitLab admin config","title":"Road map"},{"location":"guides/users/","text":"User guide This file is intended to give a brief overview of the overall structure and use of foxOps. At this time the guide is aspirational and many features will still need to be developed and the design refined. Please see contributing documentation if you wish to assist with this. Basic structure The primary syntax will be \"foxops $object $verb\". Config will be managed via a config object similar to git and pip . Configuration will be used to avoid repetition in supplying arguments e.g. Gitlab URL, access token. The primary method of nominating or identifying a gitlab project or group will be it's handle, as this is human-readable and trivial to resolve to an id. For a project this is the attribute path_with_namespace , though configuration will allow for a default namespace to fall back to. Pull config foxops project get arichtman/foxops-testing) should return a structured dump of a project. Compare objects foxops project diff $contentFoo $contentBar (I'm still thinking about whether this one should accept ids or addresses or straight json/yaml...) Plan transition foxops plan $contentFoo $contentBar should return a structured output outlining what specific actions would be undertaken to transition each diff finding to the target state, as well as any transitions that were unable to be planned (as warnings? errors?). Differentials There are some fields that would show in a raw differential that would be type 1 errors - one example is a sysmod or modified datetime value. There's not only no point updating this if it's the only property that's different, but it's impossible to actually set to a target state (barring a very broken gitlab instance). Further to this, there are some values that form the \"core\" of the attribute, such that we could identify settings that have not been removed, but rather renamed or moved. In the situation inline, the tool will identify that the rule object has not been removed, but rather renamed. The tool will also ignore the added attribute, as this cannot and should not be set external to Gitlab. In the example inline, it's likely that removal and re-addd of rules would be fine, but there will be other scenarios where this would destroy history or potentially leave objects in deadlocked states. Existing state project: rules: sqa_review: requires_users: - Andy - Jane quorum: 1 added: 20211007T00:00:00Z Target state project: rules: quality_approval: requires_users: - Andy - Jane quorum: 1 added: 20001231T12:12:12Z","title":"User guide"},{"location":"guides/users/#user-guide","text":"This file is intended to give a brief overview of the overall structure and use of foxOps. At this time the guide is aspirational and many features will still need to be developed and the design refined. Please see contributing documentation if you wish to assist with this.","title":"User guide"},{"location":"guides/users/#basic-structure","text":"The primary syntax will be \"foxops $object $verb\". Config will be managed via a config object similar to git and pip . Configuration will be used to avoid repetition in supplying arguments e.g. Gitlab URL, access token. The primary method of nominating or identifying a gitlab project or group will be it's handle, as this is human-readable and trivial to resolve to an id. For a project this is the attribute path_with_namespace , though configuration will allow for a default namespace to fall back to. Pull config foxops project get arichtman/foxops-testing) should return a structured dump of a project. Compare objects foxops project diff $contentFoo $contentBar (I'm still thinking about whether this one should accept ids or addresses or straight json/yaml...) Plan transition foxops plan $contentFoo $contentBar should return a structured output outlining what specific actions would be undertaken to transition each diff finding to the target state, as well as any transitions that were unable to be planned (as warnings? errors?).","title":"Basic structure"},{"location":"guides/users/#differentials","text":"There are some fields that would show in a raw differential that would be type 1 errors - one example is a sysmod or modified datetime value. There's not only no point updating this if it's the only property that's different, but it's impossible to actually set to a target state (barring a very broken gitlab instance). Further to this, there are some values that form the \"core\" of the attribute, such that we could identify settings that have not been removed, but rather renamed or moved. In the situation inline, the tool will identify that the rule object has not been removed, but rather renamed. The tool will also ignore the added attribute, as this cannot and should not be set external to Gitlab. In the example inline, it's likely that removal and re-addd of rules would be fine, but there will be other scenarios where this would destroy history or potentially leave objects in deadlocked states. Existing state project: rules: sqa_review: requires_users: - Andy - Jane quorum: 1 added: 20211007T00:00:00Z Target state project: rules: quality_approval: requires_users: - Andy - Jane quorum: 1 added: 20001231T12:12:12Z","title":"Differentials"},{"location":"registers/decisions/","text":"Decision register Here is the space to record any decisions of significance, and the surrounding details. This project uses templated Y-statements for brevity and structure. 00. Testing framework In the context of having to select an initial testing framework, facing no code and no peer guidance, we decided for pytest to achieve a well-supported framework that we shared with our dependency project, accepting that it may not be as modern or legible as other projects like nose2 and behave. 01. Argument module In the context of selecting an argument parsing module, facing our requirements and time shortage we decided for typer to achieve speed from intuitive syntax allowing subcommands, accepting that environment variables and configuration files will not make this iteration. Notes: jsonargparse - imperative definition, unintuitive syntax, focus on configuration files, not super mature or popular. Might use it for the config file reading. configargparse - supports a lot of what we want, just still imperative argument declaration. Look into this one eventually click - really nice and mature, plenty popular, company support even! might use this one typer - built ontop of click so all those benefits + some additional features, not super mature though popular and supports subcommands while using annotations and typing. 02. Configuration management and storage In the context of features around storing, using, and modifying configuration, facing the option to implement we decided not to implement to achieve focus on core functionality, accepting that only a handful of values would go into the configuration and it wouldn't save much over supporting .env files. See #14 for some more thoughts","title":"Decision register"},{"location":"registers/decisions/#decision-register","text":"Here is the space to record any decisions of significance, and the surrounding details. This project uses templated Y-statements for brevity and structure.","title":"Decision register"},{"location":"registers/decisions/#00-testing-framework","text":"In the context of having to select an initial testing framework, facing no code and no peer guidance, we decided for pytest to achieve a well-supported framework that we shared with our dependency project, accepting that it may not be as modern or legible as other projects like nose2 and behave.","title":"00. Testing framework"},{"location":"registers/decisions/#01-argument-module","text":"In the context of selecting an argument parsing module, facing our requirements and time shortage we decided for typer to achieve speed from intuitive syntax allowing subcommands, accepting that environment variables and configuration files will not make this iteration. Notes: jsonargparse - imperative definition, unintuitive syntax, focus on configuration files, not super mature or popular. Might use it for the config file reading. configargparse - supports a lot of what we want, just still imperative argument declaration. Look into this one eventually click - really nice and mature, plenty popular, company support even! might use this one typer - built ontop of click so all those benefits + some additional features, not super mature though popular and supports subcommands while using annotations and typing.","title":"01. Argument module"},{"location":"registers/decisions/#02-configuration-management-and-storage","text":"In the context of features around storing, using, and modifying configuration, facing the option to implement we decided not to implement to achieve focus on core functionality, accepting that only a handful of values would go into the configuration and it wouldn't save much over supporting .env files. See #14 for some more thoughts","title":"02. Configuration management and storage"},{"location":"registers/requirements/","text":"Requirements register This document contains requirements for the project. Arguments module This section outlines the needs and wants for a framework or module to manage arguments and configuration of the cli tool. All listed requirements here can be considered as desireable but not must-have. The project is far too nascent to be making hard rules at this stage. Requirements: Can define arguments declaratively using data structures, as opposed to imperatively in code Supports coalescing in environment variables Supports coalescing in from configuration file Supports @ -notation for reading values from files Allows validation of argument types Supports cli syntax of both --long-value and -lv Supports cli syntax of both -v=1234 and -v 1234 Supports cli syntax of both -v string and -v \"string\" Supports different arguments depending on the first and second e.g. push (--hands | --feet) but only pull --hands would be valid","title":"Requirements register"},{"location":"registers/requirements/#requirements-register","text":"This document contains requirements for the project.","title":"Requirements register"},{"location":"registers/requirements/#arguments-module","text":"This section outlines the needs and wants for a framework or module to manage arguments and configuration of the cli tool. All listed requirements here can be considered as desireable but not must-have. The project is far too nascent to be making hard rules at this stage. Requirements: Can define arguments declaratively using data structures, as opposed to imperatively in code Supports coalescing in environment variables Supports coalescing in from configuration file Supports @ -notation for reading values from files Allows validation of argument types Supports cli syntax of both --long-value and -lv Supports cli syntax of both -v=1234 and -v 1234 Supports cli syntax of both -v string and -v \"string\" Supports different arguments depending on the first and second e.g. push (--hands | --feet) but only pull --hands would be valid","title":"Arguments module"}]}